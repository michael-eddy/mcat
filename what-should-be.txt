use std::{
    io::{self, BufWriter, Write},
    str::FromStr,
    sync::atomic::AtomicUsize,
};

use comrak::{
    Arena, ComrakOptions, ComrakPlugins,
    html::{ChildRendering, Context, format_document_with_formatter},
    markdown_to_html_with_plugins,
    nodes::{AstNode, NodeValue},
    plugins::syntect::SyntectAdapter,
};
use rasteroid::term_misc;
use syntect::{
    highlighting::{Color, ScopeSelectors, StyleModifier, Theme, ThemeSettings},
    parsing::SyntaxSet,
};

const RESET: &str = "\x1B[0m";
const BOLD: &str = "\x1B[1m";
const ITALIC: &str = "\x1B[3m";
const UNDERLINE: &str = "\x1B[4m";
const STRIKETHROUGH: &str = "\x1B[9m";

const FG_BLACK: &str = "\x1B[30m";
const FG_RED: &str = "\x1B[31m";
const FG_GREEN: &str = "\x1B[32m";
const FG_YELLOW: &str = "\x1B[33m";
const FG_BLUE: &str = "\x1B[34m";
const FG_MAGENTA: &str = "\x1B[35m";
const FG_CYAN: &str = "\x1B[36m";
const FG_WHITE: &str = "\x1B[37m";
const FG_BRIGHT_BLACK: &str = "\x1B[90m";
const FG_BRIGHT_RED: &str = "\x1B[91m";
const FG_BRIGHT_GREEN: &str = "\x1B[92m";
const FG_BRIGHT_YELLOW: &str = "\x1B[93m";
const FG_BRIGHT_BLUE: &str = "\x1B[94m";
const FG_BRIGHT_MAGENTA: &str = "\x1B[95m";
const FG_BRIGHT_CYAN: &str = "\x1B[96m";
const FG_BRIGHT_WHITE: &str = "\x1B[97m";

const BG_BLACK: &str = "\x1B[40m";
const BG_RED: &str = "\x1B[41m";
const BG_GREEN: &str = "\x1B[42m";
const BG_YELLOW: &str = "\x1B[43m";
const BG_BLUE: &str = "\x1B[44m";
const BG_MAGENTA: &str = "\x1B[45m";
const BG_CYAN: &str = "\x1B[46m";
const BG_WHITE: &str = "\x1B[47m";
const BG_BRIGHT_BLACK: &str = "\x1B[100m";
const BG_BRIGHT_RED: &str = "\x1B[101m";
const BG_BRIGHT_GREEN: &str = "\x1B[102m";
const BG_BRIGHT_YELLOW: &str = "\x1B[103m";
const BG_BRIGHT_BLUE: &str = "\x1B[104m";
const BG_BRIGHT_MAGENTA: &str = "\x1B[105m";
const BG_BRIGHT_CYAN: &str = "\x1B[106m";
const BG_BRIGHT_WHITE: &str = "\x1B[107m";

struct AnsiContext {
    ps: SyntaxSet,
    theme: CustomTheme,
}

pub fn md_to_ansi(md: &str) -> String {
    let arena = Arena::new();
    let opts = comrak_options();
    let plugins = ComrakPlugins::default();
    let root = comrak::parse_document(&arena, md, &opts);
    eprintln!("{:?} ", root);

    let ps = SyntaxSet::load_defaults_newlines();
    let theme = CustomTheme::dark();
    let ansi_context = AnsiContext { ps, theme };

    let mut bw = BufWriter::new(Vec::new());
    format_document_with_formatter(
        root,
        &opts,
        &mut bw,
        &plugins,
        format_node_default,
        ansi_context,
    )
    .unwrap();
    String::from_utf8(bw.into_inner().unwrap()).unwrap()
}

pub fn format_node_default<'a, AnsiContext>(
    context: &mut Context<AnsiContext>,
    node: &'a AstNode<'a>,
    entering: bool,
) -> io::Result<ChildRendering> {
    match node.data.borrow().value {
        // Commonmark
        NodeValue::BlockQuote => render_block_quote(context, node, entering),
        NodeValue::Code(_) => render_code(context, node, entering),
        NodeValue::CodeBlock(_) => render_code_block(context, node, entering),
        NodeValue::Document => render_document(context, node, entering),
        NodeValue::Emph => render_emph(context, node, entering),
        NodeValue::Heading(_) => render_heading(context, node, entering),
        NodeValue::HtmlBlock(_) => render_html_block(context, node, entering),
        NodeValue::HtmlInline(_) => render_html_inline(context, node, entering),
        NodeValue::Image(_) => render_image(context, node, entering),
        NodeValue::Item(_) => render_item(context, node, entering),
        NodeValue::LineBreak => render_line_break(context, node, entering),
        NodeValue::Link(_) => render_link(context, node, entering),
        NodeValue::List(_) => render_list(context, node, entering),
        NodeValue::Paragraph => render_paragraph(context, node, entering),
        NodeValue::SoftBreak => render_soft_break(context, node, entering),
        NodeValue::Strong => render_strong(context, node, entering),
        NodeValue::Text(_) => render_text(context, node, entering),
        NodeValue::ThematicBreak => render_thematic_break(context, node, entering),

        // GFM
        NodeValue::FootnoteDefinition(_) => render_footnote_definition(context, node, entering),
        NodeValue::FootnoteReference(_) => render_footnote_reference(context, node, entering),
        NodeValue::Strikethrough => render_strikethrough(context, node, entering),
        NodeValue::Table(_) => render_table(context, node, entering),
        NodeValue::TableCell => render_table_cell(context, node, entering),
        NodeValue::TableRow(_) => render_table_row(context, node, entering),
        NodeValue::TaskItem(_) => render_task_item(context, node, entering),

        // Extensions
        NodeValue::Alert(_) => render_alert(context, node, entering),
        NodeValue::DescriptionDetails => render_description_details(context, node, entering),
        NodeValue::DescriptionItem(_) => render_description_item(context, node, entering),
        NodeValue::DescriptionList => render_description_list(context, node, entering),
        NodeValue::DescriptionTerm => render_description_term(context, node, entering),
        NodeValue::Escaped => render_escaped(context, node, entering),
        NodeValue::EscapedTag(_) => render_escaped_tag(context, node, entering),
        NodeValue::FrontMatter(_) => render_frontmatter(context, node, entering),
        NodeValue::Math(_) => render_math(context, node, entering),
        NodeValue::MultilineBlockQuote(_) => render_multiline_block_quote(context, node, entering),
        NodeValue::Raw(_) => render_raw(context, node, entering),

        NodeValue::SpoileredText => render_spoiler_text(context, node, entering),
        NodeValue::Subscript => render_subscript(context, node, entering),
        NodeValue::Superscript => render_superscript(context, node, entering),
        NodeValue::Underline => render_underline(context, node, entering),
        NodeValue::WikiLink(_) => render_wiki_link(context, node, entering),
    }
}

fn render_wiki_link<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_underline<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_superscript<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_subscript<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_spoiler_text<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_raw<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_multiline_block_quote<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_math<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_frontmatter<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_escaped_tag<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_escaped<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_description_term<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_description_list<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_description_item<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_description_details<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_alert<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_task_item<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_table_row<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_table_cell<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_table<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_strikethrough<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_footnote_reference<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_footnote_definition<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_thematic_break<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_text<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_strong<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_soft_break<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_paragraph<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_list<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_link<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_line_break<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_item<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_image<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_html_inline<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_html_block<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_heading<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_emph<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_document<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_code_block<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_code<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn render_block_quote<'a, AnsiContext>(
    context: &mut Context<'_, '_, AnsiContext>,
    node: &'a comrak::arena_tree::Node<'a, std::cell::RefCell<comrak::nodes::Ast>>,
    entering: bool,
) -> Result<ChildRendering, io::Error> {
    todo!()
}

fn comrak_options<'a>() -> ComrakOptions<'a> {
    let mut options = ComrakOptions::default();
    // âž• Enable extensions
    options.extension.strikethrough = true;
    options.extension.superscript = true;
    options.extension.tagfilter = true;
    options.extension.table = true;
    options.extension.autolink = true;
    options.extension.tasklist = true;
    options.extension.footnotes = true;
    options.extension.description_lists = true;
    options.extension.math_code = true;
    options.extension.alerts = true;

    // ðŸŽ¯ Parsing options
    options.parse.smart = true; // fancy quotes, dashes, ellipses
    options.parse.relaxed_tasklist_matching = true;

    // ðŸ’„ Render options
    options.render.unsafe_ = true;

    options
}

pub fn format_ast_node<'a>(
    node: &'a AstNode<'a>,
    output: &mut String,
    ps: &SyntaxSet,
    ts: &Theme,
    theme: &CustomTheme,
    line: &AtomicUsize,
) {
    todo!()
}

fn br() -> String {
    "â”€".repeat(term_misc::get_winsize().sc_width as usize)
}

#[derive(Debug, Clone)]
pub struct ThemeColor {
    value: String,
    color: Color,
    bg: String,
    fg: String,
}

impl From<&str> for ThemeColor {
    fn from(hex_color: &str) -> Self {
        let color = hex_to_rgba(&hex_color);
        let (r, g, b) = (color.r, color.g, color.b);

        ThemeColor {
            value: hex_color.to_owned(),
            color,
            bg: format!("\x1b[48;2;{};{};{}m", r, g, b),
            fg: format!("\x1b[38;2;{};{};{}m", r, g, b),
        }
    }
}

#[derive(Debug, Clone)]
pub struct CustomTheme {
    pub keyword: ThemeColor,
    pub function: ThemeColor,
    pub string: ThemeColor,
    pub module: ThemeColor,
    pub constant: ThemeColor,
    pub comment: ThemeColor,
    pub foreground: ThemeColor,
    pub guide: ThemeColor,
    pub background: ThemeColor,
    pub surface: ThemeColor,
}

fn hex_to_rgba(hex: &str) -> Color {
    let hex = hex.trim_start_matches('#');
    let r = u8::from_str_radix(&hex[0..2], 16).unwrap_or(255);
    let g = u8::from_str_radix(&hex[2..4], 16).unwrap_or(255);
    let b = u8::from_str_radix(&hex[4..6], 16).unwrap_or(255);
    Color { r, g, b, a: 255 }
}

impl CustomTheme {
    pub fn dark() -> Self {
        CustomTheme {
            keyword: "#FF7733".into(),
            function: "#FFEE99".into(),
            string: "#95FB79".into(),
            module: "#82AAFF".into(),
            constant: "#D2A6FF".into(),
            comment: "#5C6773".into(),
            foreground: "#FFFFFF".into(),
            guide: "#2D3640".into(),
            background: "#15161B".into(),
            surface: "#20202b".into(),
        }
    }

    pub fn to_syntect_theme(&self) -> Theme {
        let mut settings = ThemeSettings::default();
        settings.foreground = Some(self.foreground.color);
        settings.background = Some(self.background.color);
        settings.guide = Some(self.guide.color);

        let mut theme = Theme {
            name: None,
            author: None,
            settings,
            scopes: vec![],
        };

        fn create_selectors(selectors: &str) -> ScopeSelectors {
            ScopeSelectors::from_str(selectors).unwrap_or_default()
        }
        fn create_style(color: Color) -> StyleModifier {
            StyleModifier {
                foreground: Some(color),
                background: None,
                font_style: None,
            }
        }

        theme.scopes.push(syntect::highlighting::ThemeItem {
            scope: create_selectors("keyword, storage.modifier, storage.type"),
            style: create_style(self.keyword.color),
        });

        theme.scopes.push(syntect::highlighting::ThemeItem {
            scope: create_selectors("entity.name.function, support.function, variable.function"),
            style: create_style(self.function.color),
        });

        theme.scopes.push(syntect::highlighting::ThemeItem {
            scope: create_selectors("module, struct, enum, generic, path"),
            style: create_style(self.module.color),
        });

        theme.scopes.push(syntect::highlighting::ThemeItem {
            scope: create_selectors("string, punctuation.string"),
            style: create_style(self.string.color),
        });

        theme.scopes.push(syntect::highlighting::ThemeItem {
            scope: create_selectors("constant, support.type"),
            style: create_style(self.constant.color),
        });

        theme.scopes.push(syntect::highlighting::ThemeItem {
            scope: create_selectors("comment, punctuation.comment"),
            style: create_style(self.comment.color),
        });

        theme.scopes.push(syntect::highlighting::ThemeItem {
            scope: create_selectors("variable, operator, punctuation, block"),
            style: create_style(self.foreground.color),
        });

        theme
    }

    pub fn to_html_style(&self) -> String {
        todo!()
    }
}

pub fn md_to_html(markdown: &str, css_path: Option<&str>) -> String {
    let options = comrak_options();

    let mut plugins = ComrakPlugins::default();
    let adapter = SyntectAdapter::new(None);
    plugins.render.codefence_syntax_highlighter = Some(&adapter);

    let css_content = match css_path {
        Some("dark") => Some(include_str!("../styles/dark.css").to_string()),
        Some("light") => Some(include_str!("../styles/light.css").to_string()),
        Some(path) => std::fs::read_to_string(path).ok(),
        None => None,
    };

    let html = markdown_to_html_with_plugins(markdown, &options, &plugins);
    match css_content {
        Some(css) => format!(
            r#"
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>{}</style>
</head>
<body>
  {}
</body>
</html>
"#,
            css, html
        ),
        None => html,
    }
}
